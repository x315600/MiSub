/**
 * åœ°ç†è¯†åˆ«å·¥å…·æ¨¡å—
 * æä¾›èŠ‚ç‚¹åœ°åŒºè¯†åˆ«å’Œç›¸å…³åŠŸèƒ½
 */

/**
 * åœ°åŒºå…³é”®è¯æ˜ å°„è¡¨
 * æ”¯æŒå¤šè¯­è¨€åœ°åŒºè¯†åˆ«
 */
export const REGION_KEYWORDS = {
    'é¦™æ¸¯': ['HK', 'é¦™æ¸¯', 'Hong Kong', 'HongKong', 'HongKong', 'Hong Kong'],
    'å°æ¹¾': ['TW', 'å°æ¹¾', 'Taiwan', 'Taipei', 'Taipei'],
    'æ–°åŠ å¡': ['SG', 'æ–°åŠ å¡', 'Singapore'],
    'æ—¥æœ¬': ['JP', 'æ—¥æœ¬', 'Japan', 'Tokyo', 'Osaka', 'Tokyo', 'Osaka', 'Fukuoka', 'Yokohama'],
    'ç¾å›½': ['US', 'ç¾å›½', 'USA', 'United States', 'America', 'Los Angeles', 'New York', 'San Francisco', 'Seattle', 'Chicago'],
    'éŸ©å›½': ['KR', 'éŸ©å›½', 'Korea', 'Seoul', 'Seoul'],
    'è‹±å›½': ['UK', 'è‹±å›½', 'Britain', 'London', 'London', 'Manchester'],
    'å¾·å›½': ['DE', 'å¾·å›½', 'Germany', 'Frankfurt', 'Frankfurt', 'Berlin', 'Munich'],
    'æ³•å›½': ['FR', 'æ³•å›½', 'France', 'Paris', 'Paris', 'Lyon', 'Marseille'],
    'åŠ æ‹¿å¤§': ['CA', 'åŠ æ‹¿å¤§', 'Canada', 'Toronto', 'Vancouver', 'Montreal'],
    'æ¾³å¤§åˆ©äºš': ['AU', 'æ¾³å¤§åˆ©äºš', 'Australia', 'Sydney', 'Melbourne', 'Brisbane', 'Perth'],
    'è·å…°': ['NL', 'è·å…°', 'Netherlands', 'Amsterdam', 'Amsterdam', 'Rotterdam'],
    'ä¿„ç½—æ–¯': ['RU', 'ä¿„ç½—æ–¯', 'Russia', 'Moscow', 'Moscow', 'Saint Petersburg'],
    'å°åº¦': ['IN', 'å°åº¦', 'India', 'Mumbai', 'Delhi', 'Bangalore'],
    'åœŸè€³å…¶': ['TR', 'åœŸè€³å…¶', 'Turkey', 'Istanbul', 'Istanbul', 'Ankara'],
    'é©¬æ¥è¥¿äºš': ['MY', 'é©¬æ¥è¥¿äºš', 'Malaysia', 'Kuala Lumpur'],
    'æ³°å›½': ['TH', 'æ³°å›½', 'Thailand', 'Bangkok', 'Bangkok', 'Pattaya'],
    'è¶Šå—': ['VN', 'è¶Šå—', 'Vietnam', 'Ho Chi Minh City', 'Hanoi'],
    'è²å¾‹å®¾': ['PH', 'è²å¾‹å®¾', 'Philippines', 'Manila', 'Cebu'],
    'å°å°¼': ['ID', 'å°å°¼', 'Indonesia', 'Jakarta', 'Surabaya', 'Bandung'],
    'ç‘å£«': ['CH', 'ç‘å£«', 'Switzerland', 'Zurich', 'Geneva'],
    'æ„å¤§åˆ©': ['IT', 'æ„å¤§åˆ©', 'Italy', 'Rome', 'Milan', 'Naples'],
    'è¥¿ç­ç‰™': ['ES', 'è¥¿ç­ç‰™', 'Spain', 'Madrid', 'Barcelona'],
    'å·´è¥¿': ['BR', 'å·´è¥¿', 'Brazil', 'SÃ£o Paulo', 'Rio de Janeiro'],
    'é˜¿æ ¹å»·': ['AR', 'é˜¿æ ¹å»·', 'Argentina', 'Buenos Aires'],
    'å¢¨è¥¿å“¥': ['MX', 'å¢¨è¥¿å“¥', 'Mexico', 'Mexico City'],
    'å—é': ['ZA', 'å—é', 'South Africa', 'Johannesburg', 'Cape Town'],
    'åŸƒåŠ': ['EG', 'åŸƒåŠ', 'Egypt', 'Cairo'],
    'ä»¥è‰²åˆ—': ['IL', 'ä»¥è‰²åˆ—', 'Israel', 'Tel Aviv', 'Jerusalem'],
    'é˜¿è”é…‹': ['AE', 'é˜¿è”é…‹', 'UAE', 'Dubai', 'Abu Dhabi', 'Sharjah'],
    'æ²™ç‰¹': ['SA', 'æ²™ç‰¹', 'Saudi Arabia', 'Riyadh', 'Jeddah'],
    'å°åº¦å°¼è¥¿äºš': ['ID', 'å°åº¦å°¼è¥¿äºš', 'Indonesia', 'Jakarta', 'Surabaya'],
    'æ³¢å…°': ['PL', 'æ³¢å…°', 'Poland', 'Warsaw', 'Krakow'],
    'æ·å…‹': ['CZ', 'æ·å…‹', 'Czech Republic', 'Prague'],
    'åŒˆç‰™åˆ©': ['HU', 'åŒˆç‰™åˆ©', 'Hungary', 'Budapest'],
    'ç½—é©¬å°¼äºš': ['RO', 'ç½—é©¬å°¼äºš', 'Romania', 'Bucharest'],
    'ä¿åŠ åˆ©äºš': ['BG', 'ä¿åŠ åˆ©äºš', 'Bulgaria', 'Sofia'],
    'å¸Œè…Š': ['GR', 'å¸Œè…Š', 'Greece', 'Athens', 'Thessaloniki'],
    'è‘¡è„ç‰™': ['PT', 'è‘¡è„ç‰™', 'Portugal', 'Lisbon', 'Porto'],
    'ç‘å…¸': ['SE', 'ç‘å…¸', 'Sweden', 'Stockholm', 'Gothenburg'],
    'æŒªå¨': ['NO', 'æŒªå¨', 'Norway', 'Oslo', 'Bergen'],
    'ä¸¹éº¦': ['DK', 'ä¸¹éº¦', 'Denmark', 'Copenhagen', 'Aarhus'],
    'èŠ¬å…°': ['FI', 'èŠ¬å…°', 'Finland', 'Helsinki'],
    'å¥¥åœ°åˆ©': ['AT', 'å¥¥åœ°åˆ©', 'Austria', 'Vienna', 'Salzburg']
};

/**
 * [æ–°å¢] åœ°åŒº Emoji æ˜ å°„è¡¨
 */
export const REGION_EMOJI = {
    'é¦™æ¸¯': 'ğŸ‡­ğŸ‡°',
    'å°æ¹¾': 'ğŸ‡¨ğŸ‡³',
    'æ–°åŠ å¡': 'ğŸ‡¸ğŸ‡¬',
    'æ—¥æœ¬': 'ğŸ‡¯ğŸ‡µ',
    'ç¾å›½': 'ğŸ‡ºğŸ‡¸',
    'éŸ©å›½': 'ğŸ‡°ğŸ‡·',
    'è‹±å›½': 'ğŸ‡¬ğŸ‡§',
    'å¾·å›½': 'ğŸ‡©ğŸ‡ª',
    'æ³•å›½': 'ğŸ‡«ğŸ‡·',
    'åŠ æ‹¿å¤§': 'ğŸ‡¨ğŸ‡¦',
    'æ¾³å¤§åˆ©äºš': 'ğŸ‡¦ğŸ‡º',
    'è·å…°': 'ğŸ‡³ğŸ‡±',
    'ä¿„ç½—æ–¯': 'ğŸ‡·ğŸ‡º',
    'å°åº¦': 'ğŸ‡®ğŸ‡³',
    'åœŸè€³å…¶': 'ğŸ‡¹ğŸ‡·',
    'é©¬æ¥è¥¿äºš': 'ğŸ‡²ğŸ‡¾',
    'æ³°å›½': 'ğŸ‡¹ğŸ‡­',
    'è¶Šå—': 'ğŸ‡»ğŸ‡³',
    'è²å¾‹å®¾': 'ğŸ‡µğŸ‡­',
    'å°å°¼': 'ğŸ‡®ğŸ‡©',
    'ç‘å£«': 'ğŸ‡¨ğŸ‡­',
    'æ„å¤§åˆ©': 'ğŸ‡®ğŸ‡¹',
    'è¥¿ç­ç‰™': 'ğŸ‡ªğŸ‡¸',
    'å·´è¥¿': 'ğŸ‡§ğŸ‡·',
    'é˜¿æ ¹å»·': 'ğŸ‡¦ğŸ‡·',
    'å¢¨è¥¿å“¥': 'ğŸ‡²ğŸ‡½',
    'å—é': 'ğŸ‡¿ğŸ‡¦',
    'åŸƒåŠ': 'ğŸ‡ªğŸ‡¬',
    'ä»¥è‰²åˆ—': 'ğŸ‡®ğŸ‡±',
    'é˜¿è”é…‹': 'ğŸ‡¦ğŸ‡ª',
    'æ²™ç‰¹': 'ğŸ‡¸ğŸ‡¦',
    'æ³¢å…°': 'ğŸ‡µğŸ‡±',
    'æ·å…‹': 'ğŸ‡¨ğŸ‡¿',
    'åŒˆç‰™åˆ©': 'ğŸ‡­ğŸ‡º',
    'ç½—é©¬å°¼äºš': 'ğŸ‡·ğŸ‡´',
    'å¸Œè…Š': 'ğŸ‡¬ğŸ‡·',
    'è‘¡è„ç‰™': 'ğŸ‡µğŸ‡¹',
    'ç‘å…¸': 'ğŸ‡¸ğŸ‡ª',
    'æŒªå¨': 'ğŸ‡³ğŸ‡´',
    'ä¸¹éº¦': 'ğŸ‡©ğŸ‡°',
    'èŠ¬å…°': 'ğŸ‡«ğŸ‡®',
    'å¥¥åœ°åˆ©': 'ğŸ‡¦ğŸ‡¹',
    'å…¶ä»–': 'ğŸŒ'
};

function normalizeBase64(input) {
    let s = String(input || '').trim().replace(/\s+/g, '');
    if (!s) return '';
    if (s.includes('%')) {
        try {
            s = decodeURIComponent(s);
        } catch {
            // keep raw when decode fails
        }
    }
    s = s.replace(/-/g, '+').replace(/_/g, '/');
    while (s.length % 4) s += '=';
    return s;
}

function isLikelyBase64(input) {
    const s = String(input || '').trim();
    if (!s) return false;
    if (!/^[A-Za-z0-9+/=_-]+$/.test(s)) return false;
    return s.length >= 6;
}

function tryDecodeBase64(input) {
    if (!isLikelyBase64(input)) return null;
    try {
        return atob(normalizeBase64(input));
    } catch {
        return null;
    }
}

function parseHostPort(value) {
    let segment = String(value || '');
    if (!segment) return { server: '', port: '' };
    const cut = segment.search(/[/?#]/);
    if (cut !== -1) segment = segment.slice(0, cut);

    if (segment.startsWith('[')) {
        const closeBracket = segment.indexOf(']');
        if (closeBracket !== -1) {
            const server = segment.slice(1, closeBracket);
            const after = segment.slice(closeBracket + 1);
            const port = after.startsWith(':') ? after.slice(1).split('/')[0] : '';
            return { server, port };
        }
    }

    const parts = segment.split(':');
    if (parts.length >= 2) {
        return { server: parts[0], port: parts[1].split('/')[0] };
    }
    return { server: segment, port: '' };
}

/**
 * ä»èŠ‚ç‚¹åç§°ä¸­è¯†åˆ«åœ°åŒº
 * @param {string} nodeName - èŠ‚ç‚¹åç§°
 * @returns {string} è¯†åˆ«å‡ºçš„åœ°åŒºï¼Œå¦‚æœªè¯†åˆ«è¿”å›"å…¶ä»–"
 */
export function extractNodeRegion(nodeName) {
    if (!nodeName || typeof nodeName !== 'string') {
        return 'å…¶ä»–';
    }

    const normalizedNodeName = nodeName.toLowerCase();

    // éå†æ‰€æœ‰åœ°åŒºå…³é”®è¯
    for (const [regionName, keywords] of Object.entries(REGION_KEYWORDS)) {
        for (const keyword of keywords) {
            const lowerKeyword = keyword.toLowerCase();

            // å¯¹äºçŸ­å…³é”®è¯ï¼ˆ2-3ä¸ªå­—ç¬¦çš„çº¯è‹±æ–‡ï¼‰ï¼Œè¦æ±‚åŒ¹é…ç‹¬ç«‹å•è¯è¾¹ç•Œ
            // é¿å… "kristi" åŒ¹é… "kr"ï¼Œ"user" åŒ¹é… "us" ç­‰è¯¯åŒ¹é…
            if (lowerKeyword.length <= 3 && /^[a-z]+$/i.test(lowerKeyword)) {
                // ä½¿ç”¨æ›´å…¼å®¹çš„æ–¹å¼æ£€æŸ¥å•è¯è¾¹ç•Œï¼ˆä¸ä½¿ç”¨ lookbehindï¼‰
                const idx = normalizedNodeName.indexOf(lowerKeyword);
                if (idx !== -1) {
                    // æ£€æŸ¥å‰ä¸€ä¸ªå­—ç¬¦
                    const charBefore = idx > 0 ? normalizedNodeName[idx - 1] : '';
                    const isLetterBefore = charBefore && /[a-z]/i.test(charBefore);

                    // æ£€æŸ¥åä¸€ä¸ªå­—ç¬¦
                    const charAfter = normalizedNodeName[idx + lowerKeyword.length] || '';
                    const isLetterAfter = charAfter && /[a-z]/i.test(charAfter);

                    // åªæœ‰å½“å‰åéƒ½ä¸æ˜¯å­—æ¯æ—¶æ‰åŒ¹é…
                    if (!isLetterBefore && !isLetterAfter) {
                        return regionName;
                    }
                }
            } else {
                // å¯¹äºé•¿å…³é”®è¯æˆ–ä¸­æ–‡ï¼Œç›´æ¥ä½¿ç”¨ includes
                if (normalizedNodeName.includes(lowerKeyword)) {
                    return regionName;
                }
            }
        }
    }

    return 'å…¶ä»–';
}

/**
 * è·å–æ‰€æœ‰æ”¯æŒçš„åœ°åŒºåˆ—è¡¨
 * @returns {string[]} æ”¯æŒçš„åœ°åŒºåç§°æ•°ç»„
 */
export function getSupportedRegions() {
    return Object.keys(REGION_KEYWORDS);
}

/**
 * è·å–æŒ‡å®šåœ°åŒºçš„æ‰€æœ‰å…³é”®è¯
 * @param {string} region - åœ°åŒºåç§°
 * @returns {string[]} è¯¥åœ°åŒºçš„æ‰€æœ‰å…³é”®è¯ï¼Œå¦‚åœ°åŒºä¸å­˜åœ¨è¿”å›ç©ºæ•°ç»„
 */
export function getRegionKeywords(region) {
    return REGION_KEYWORDS[region] || [];
}

/**
 * [æ–°å¢] è·å–åœ°åŒº Emoji
 * @param {string} region - åœ°åŒºåç§°
 * @returns {string} å¯¹åº”çš„ Emojiï¼Œå¦‚æœæœªæ‰¾åˆ°åˆ™è¿”å›ç©ºå­—ç¬¦ä¸²
 */
export function getRegionEmoji(region) {
    return REGION_EMOJI[region] || '';
}

/**
 * æ£€æŸ¥èŠ‚ç‚¹åç§°æ˜¯å¦åŒ…å«æŒ‡å®šåœ°åŒº
 * @param {string} nodeName - èŠ‚ç‚¹åç§°
 * @param {string} region - è¦æ£€æŸ¥çš„åœ°åŒº
 * @returns {boolean} æ˜¯å¦åŒ…å«è¯¥åœ°åŒº
 */
export function containsRegion(nodeName, region) {
    if (!nodeName || !region || !REGION_KEYWORDS[region]) {
        return false;
    }

    const normalizedNodeName = nodeName.toLowerCase();
    const keywords = REGION_KEYWORDS[region];

    for (const keyword of keywords) {
        if (normalizedNodeName.includes(keyword.toLowerCase())) {
            return true;
        }
    }

    return false;
}

/**
 * è·å–èŠ‚ç‚¹çš„è¯¦ç»†ä¿¡æ¯ï¼ˆåè®®ã€åç§°ã€åœ°åŒºç­‰ï¼‰
 * @param {string} nodeUrl - èŠ‚ç‚¹URL
 * @returns {Object} èŠ‚ç‚¹è¯¦ç»†ä¿¡æ¯
 */
export function parseNodeInfo(nodeUrl) {
    if (!nodeUrl || typeof nodeUrl !== 'string') {
        return {
            protocol: 'unknown',
            name: 'æœªå‘½åèŠ‚ç‚¹',
            region: 'å…¶ä»–',
            url: nodeUrl
        };
    }

    // æå–åè®®
    const protocolMatch = nodeUrl.match(/^(.*?):\/\//);
    const protocol = protocolMatch ? protocolMatch[1].toLowerCase() : 'unknown';

    // æå–èŠ‚ç‚¹åç§°
    let nodeName = '';
    const hashIndex = nodeUrl.lastIndexOf('#');
    if (hashIndex !== -1) {
        try {
            nodeName = decodeURIComponent(nodeUrl.substring(hashIndex + 1));
        } catch (e) {
            nodeName = nodeUrl.substring(hashIndex + 1);
        }
    }

    // [å¢å¼º] å¦‚æœ Hash ä¸­æ²¡æœ‰åç§°ï¼Œå°è¯•ä» URL å‚æ•°ä¸­æå– (æ”¯æŒ remarks, des, remark)
    if (!nodeName) {
        const paramsMatch = nodeUrl.match(/[?&](remarks|des|remark)=([^&#]+)/);
        if (paramsMatch && paramsMatch[2]) {
            try {
                nodeName = decodeURIComponent(paramsMatch[2]);
            } catch (e) {
                nodeName = paramsMatch[2];
            }
        }
    }

    // å¦‚æœæ²¡æœ‰åç§°ï¼Œä»URLç”Ÿæˆä¸€ä¸ª
    if (!nodeName) {
        // ä»URLä¸­æå–ä¸€äº›ä¿¡æ¯ä½œä¸ºåç§°
        const urlWithoutProtocol = nodeUrl.replace(/^[^:]*:\/\//, '');
        const urlParts = urlWithoutProtocol.split(/[:@?#]/);
        nodeName = urlParts[0] || 'æœªå‘½åèŠ‚ç‚¹';
    }

    // [ä¿®å¤] å°†å°æ¹¾æ——å¸œæ›¿æ¢ä¸ºä¸­å›½å›½æ——
    nodeName = nodeName.replace(/ğŸ‡¹ğŸ‡¼/g, 'ğŸ‡¨ğŸ‡³');

    // [æ–°å¢] æå–æœåŠ¡å™¨åœ°å€å’Œç«¯å£
    let server = '';
    let port = '';

    try {
        if (protocol === 'vmess') {
            const base64Part = nodeUrl.replace('vmess://', '');
            if (base64Part && !base64Part.includes('@')) { // æ’é™¤å¯èƒ½æ˜¯æ˜æ–‡çš„æƒ…å†µ(è™½ç„¶vmesså°‘è§)
                try {
                    // å¤„ç† URL-safe Base64 å­—ç¬¦
                    let safeBody = base64Part.replace(/-/g, '+').replace(/_/g, '/');
                    // è¡¥å…¨ Padding
                    while (safeBody.length % 4) {
                        safeBody += '=';
                    }
                    const jsonStr = atob(safeBody); // ä½¿ç”¨ decodeURIComponent(escape(atob(safeBody))) å¤„ç†ä¸­æ–‡? 
                    // ä¸, atob è§£ç åé€šå¸¸æ˜¯ UTF-8 å­—èŠ‚æµä¹±ç  if directly used as string for Chinese
                    // éœ€è¦ç”¨ TextDecoder
                    const binaryString = atob(safeBody);
                    const bytes = new Uint8Array(binaryString.length);
                    for (let i = 0; i < binaryString.length; i++) {
                        bytes[i] = binaryString.charCodeAt(i);
                    }
                    const decodedStr = new TextDecoder('utf-8').decode(bytes);

                    const config = JSON.parse(decodedStr);
                    server = config.add || config.host || '';
                    port = config.port || '';
                    // [Fix] æå–åç§°
                    if (config.ps) {
                        nodeName = config.ps;
                    }
                } catch (e) {
                    console.debug('[GeoUtils] VMess base64 decode failed:', e);
                }
            }
        } else if (protocol === 'ss') {
            // ss://base64(user:pass@host:port)#name
            // æˆ–è€… ss://base64(user:pass)@host:port#name
            let body = nodeUrl.substring(5); // remove ss://
            const hIndex = body.indexOf('#');
            if (hIndex !== -1) body = body.substring(0, hIndex);
            const qIndex = body.indexOf('?');
            if (qIndex !== -1) body = body.substring(0, qIndex);

            const atLast = body.lastIndexOf('@');
            let serverPart = '';
            if (atLast !== -1) {
                // æ˜æ–‡æˆ– SIP002 (base64 userinfo)
                serverPart = body.substring(atLast + 1);
            } else {
                const decoded = tryDecodeBase64(body);
                if (decoded && decoded.includes('@')) {
                    serverPart = decoded.substring(decoded.lastIndexOf('@') + 1);
                } else {
                    serverPart = body;
                }
            }

            const parsed = parseHostPort(serverPart);
            server = parsed.server;
            port = parsed.port;
        } else {
            // é€šç”¨æ ¼å¼: protocol://user@host:port... æˆ– protocol://host:port...
            // vless, trojan, hysteria2, socks5, http ç­‰
            // å»æ‰ protocol://
            let body = nodeUrl.substring(nodeUrl.indexOf('://') + 3);
            const hIndex = body.indexOf('#');
            if (hIndex !== -1) body = body.substring(0, hIndex);

            const qIndex = body.indexOf('?');
            if (qIndex !== -1) body = body.substring(0, qIndex);

            const atIndex = body.lastIndexOf('@');
            let serverPart = (atIndex !== -1) ? body.substring(atIndex + 1) : body;

            // [æ–°å¢] æ£€æµ‹ Base64 ç¼–ç çš„ç”¨æˆ·ä¿¡æ¯ï¼ˆæŸäº›éæ ‡å‡† VLESS URLï¼‰
            // æ ¼å¼ï¼švless://Base64(auto:uuid@host:port)?params
            if (atIndex === -1 && protocol === 'vless' && body.length > 20) {
                try {
                    // å°è¯• Base64 è§£ç 
                    let b64 = body.replace(/-/g, '+').replace(/_/g, '/');
                    while (b64.length % 4) b64 += '=';
                    const binaryString = atob(b64);
                    const bytes = new Uint8Array(binaryString.length);
                    for (let i = 0; i < binaryString.length; i++) {
                        bytes[i] = binaryString.charCodeAt(i);
                    }
                    const decoded = new TextDecoder('utf-8').decode(bytes);
                    // æ£€æŸ¥è§£ç ç»“æœæ˜¯å¦åŒ…å« @ ç¬¦å·ï¼ˆå½¢å¦‚ auto:uuid@host:portï¼‰
                    if (decoded.includes('@')) {
                        const decodedAtIndex = decoded.lastIndexOf('@');
                        serverPart = decoded.substring(decodedAtIndex + 1);
                    }
                } catch (e) {
                    // Base64 è§£ç å¤±è´¥ï¼Œç»§ç»­ä½¿ç”¨åŸé€»è¾‘
                    console.debug('[GeoUtils] VLESS base64 decode attempt failed (expected for standard format)');
                }
            }

            // å¤„ç† IPv6 [::1]:port
            if (serverPart.startsWith('[')) {
                const closeBracket = serverPart.indexOf(']');
                if (closeBracket !== -1) {
                    server = serverPart.substring(1, closeBracket);
                    const afterBracket = serverPart.substring(closeBracket + 1);
                    if (afterBracket.startsWith(':')) {
                        port = afterBracket.substring(1).split('/')[0];
                    }
                }
            } else {
                const parts = serverPart.split(':');
                if (parts.length >= 2) {
                    server = parts[0];
                    port = parts[1].split('/')[0];
                }
            }
        }
    } catch (e) {
        console.error('Error extracting server/port:', e);
    }

    // è¯†åˆ«åœ°åŒº
    const region = extractNodeRegion(nodeName);

    return {
        protocol,
        name: nodeName,
        region,
        server,
        port,
        url: nodeUrl
    };
}

/**
 * ç»Ÿè®¡èŠ‚ç‚¹åœ°åŒºåˆ†å¸ƒ
 * @param {Array} nodes - èŠ‚ç‚¹æ•°ç»„
 * @returns {Object} åœ°åŒºç»Ÿè®¡ä¿¡æ¯
 */
export function calculateRegionStats(nodes) {
    const stats = {};
    const total = nodes.length;

    nodes.forEach(node => {
        const region = extractNodeRegion(node.name || '');
        stats[region] = (stats[region] || 0) + 1;
    });

    // æ·»åŠ ç™¾åˆ†æ¯”ä¿¡æ¯
    for (const [region, count] of Object.entries(stats)) {
        stats[region] = {
            count,
            percentage: Math.round((count / total) * 100)
        };
    }

    return stats;
}
